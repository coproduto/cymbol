package walker;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.antlr.v4.runtime.*;
import autogenerated.CymbolBaseVisitor;
import autogenerated.CymbolParser;

public class CymbolCallGraphVisitor extends CymbolBaseVisitor<Void> {
	private final List<Token> funcIDs = new ArrayList<Token>();
	
    @Override public Void visitFuncDecl(CymbolParser.FuncDeclContext ctx) { 
        boolean hasItem = false;
        Iterator<Token> funcIDsAsIterator = funcIDs.iterator();
        while (funcIDsAsIterator.hasNext()){
            Token it = funcIDsAsIterator.next();
            if (it == ctx.ID().getSymbol())
                hasItem = true;
        }
		
        if (!hasItem){
            //Escrever no arquivo: "n" + funcIDs.length + "[label=\"" + ctx.type() + ctx.getSymbol().getText() + "(" + ctx.paramTypeList().paramType() + ")\"];"
            funcIDs.add(ctx.ID().getSymbol());
        }
		
        return visitChildren(ctx); 
    }

    @Override public Void visitFunctionCallExpr(CymbolParser.FunctionCallExprContext ctx) { 
		
        int origin, destination, i = 1;
		
        Iterator<Token> funcIDsAsIterator = funcIDs.iterator();
        while (funcIDsAsIterator.hasNext()){
            Token it = funcIDsAsIterator.next();
            if (it == ctx.ID().getSymbol())
                destination = i;
            /*if (it == ctx.ID().getSymbol())
             origin = i;*/
            i++;
        }
		
        //Escrever no arquivo: "n" + origin + " -> n" + destination +";"
		
        return visitChildren(ctx); 
    }    
}
